NoStack Data
============
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [Data Structure](#data-structure)
- [Units](#units)
- [User Classes](#user-classes)
  - [Authorization](#authorization)
- [Query details](#query-details)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

Understanding how data is organized in NoStack makes working with app flows simpler.

# Data Structure
NoStack stores types of data and their instances.  Each instance contains an autogenerated id and a value.  
  
  For instance, you might have in your application a type `restaurant`, which may have 300 instances, each of which has a name and an autogenerated id.

Every instance is owned by a user.

Each type name must be unique within a given stack.  For instance, you can't have two types named `restaurant`.

Types have `dataTypes`.  Currently, the following dataTypes are supported:
* string (the default)
* number
* boolean
* grouping: a type that contains no value, but that groups other types.  For instance: a grouping `degree` may group `school`, `department`, `title`, `year`.

# Units
Interfaces for NoStack applications contain "units".  Every unit is stored with its own query.

A unit is fundamentally a hierarchy of types.  For instance, a unit might contain at its root `restaurant`, with `cuisine` and `rating` as children.

A parent-child relationship is called an association, which is shortened to `assn` in nostack.  An [NFS](NFSlanguage.md) specification of an assn can also specify various assn types, as discussed below.

Any given type can only appear one time in a given unit.  That said, units can be
combined, so that a user interface, and it's underlying query, may 
contain the same data type used different
ways.

A unit also can include actions that can be performed with data.  Example include
updating a value, sending a message to a user, etc. (Note: many such actions must still be implemented as of now.)

#  User Classes
A stack can be accessed by any number of user classes.  For instance, a marketplace could have two classes: `buyer` and `seller`. Each class can access the server exlusively via declared units belonging to them. 

There is an additional class called `moderator`.  Currently, only one moderator account is permitted for a stack.  The moderator is automatically registered as each of the other user classes as well, so that they can log in as any of them.

Note that user classes are also types.  So for instance `buyer` and `seller` can appear in hierarchies of data contained in units. That is useful to associate them to types of data.  For instance, `seller` might be associated to `distributionCenter`. 

## Authorization
Auth flow is built into NoStack applications. It is simple to use the CLI to create a starter app for any given user class.  Registration, logging in and out and sessions are taken care of for you.
 
Access to data is also controlled.  Every unit is owned by a single user class, which has access to that unit.  Nobody else does.  The moderator also can have access to separate units, enabling control.

Data is owned by normal users unless it is specified as for the moderator type.  Nobody but the owner can modify data.  A moderator can also be permitted to enter data.  For instance, a moderator might own the standard `categories` for items sold in a marketplace, which makes it simple to update them as needed.

# Query details
As stated above, every unit naturally forms a query, accessible with the API query `unitData`. 

* The hierarchy showshow the data is joined.  
* One or more of the types in the unit are selected. A selected type  in a unit gets returned to the front end.  It is analogous to a field that shows up in the "SELECT" clause of an SQL query.
* One or more types may be constrained. A constraint limits the data returned. A unit and the type to be constrained must be specified.  Also, a constraint value
     is required.  That is normally a variable name which can
     then be set in front end code.  
     
     There are two types of
     constraints: `ID` and `Value`.  Constraining by `ID` returns the instance having the id specified.  Constraining by value will return any instances that satisfy the condition provided. (Note: in the alpha version only `ID` constraints are functional.)

     A few reserved words for constraints.  The main
     one is __currentUser__, which is the id for the user sending an API request.
     If you set the constraint value to __currentUser__, then
     the code generated will set it as such.  Otherwise, the constraint value is just a string used for a variable name that gets set in the code.  For instance, you might have a value of `restaurantId`, which can be set for the unitData query in the front end code. \[Note: the name that you give for the constraint
     value for an ID constraint is purely for code readability.]
     
 * Two units can be "connected", which does not affect the back end data, but which will affect front end code generated.  A connecting *type* must be shared between the
   units.
   
   For instance, two units may share a type `restaurant`: `cityInfo` and `restaurantInfo`.  So for every city, a list of restaurants in the city will appear, and for each restaurant the restaurantInfo will appear.  
   
   Usually, a connecting type will be a constrained type for the child unit.  When a unit A is connected to parent unit B, a component generated for B will contain A as a subcomponent with an instance for every instance of the connecting type.
   
See [The NFS Language](NFSlanguage.md) for more information about how to specify all of the data elements for NoStack in the NFS app flow language.

[Return to Main Document](../../README.md)
